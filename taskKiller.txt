================================================================================
    何に何分かかったか記録するソフトを書いてみる
================================================================================

[完了] .git ディレクトリーなどを非表示にする
[完了] ソリューションを作成
[完了] レポジトリーを作成
[完了] プロパティーをチェック
[完了] 名前を決める
[完了] .gitignore を作る
[完了] レポジトリーをクローン
[完了] 全てのファイルをチェック
[完了] いったんコミット（繰り返す）
[完了] メモ

    何をするか書き、開始ボタンを押す。それだけやって終わったなら終了ボタンまたは次のタスクを書いて開始ボタンを押し、グダグダになったならその旨を記録するボタンを押す。どのくらい集中できているかが分かる。また、タスクのカテゴリーを設定できれば、どういうことにトータル何分かけたかも分かる。

    --------------------------------------------------------------------------------

    タスク管理はそれなりにできている。自分の問題は、職場で働いているとか、上司への報告があるとかではないことにより、ちょっと何か他のことに興味を持ったり、ちょっとメールを書こうと思ったりにより、そのことに没頭し、一気に何時間もかけてしまうこと。脱線が激しく、すぐに復旧しない。そのため、自分の時間の使い方を見える化してみるのは効果的かもしれない。レコーディングダイエットのようなこと。

    --------------------------------------------------------------------------------

    ログの例:

    ○年○月○日

    ○時○分
        タスク1

    ○時○分
        タスク2
        タスク3

    ○時○分
        タスク4
        グダグダ

    ○時○分
        不詳

    何かを始め、それだけやり、次のタスクに移行したなら、タスク1のようになる。

    何かを始め、ついでに他のこともやったなら、「今やっていること」のところにそのことを書き足して確定したい。

    何かを始め、途中で子供と遊ぶことになったなどでグダグダになれば、また仕事に戻れてそれが終わったときに「終わったが、それだけに集中できたわけでない」を入れたい。そうでないと、その作業への所要時間がおかしくなる。

    タスク4が終わり、いったん飯だとかで机を離れるときには、次のタスクを指定せず「終了」ボタンを押す。その場合、それからの時間は不詳扱いになる。

    --------------------------------------------------------------------------------

    土日連続で子供とプールに行き、昨日（日曜）の晩は、運動でアドレナリンが出たのか、頭は覚醒しているのに回転が悪く、興奮状態にあるのに思考力がないという変な状態だった。その状態で友達にメールを書き始めては、全く聞かれていないことまで、ただ自分がそういう話を久々に書いてみると楽しいということだけで書き、気付けば2時間くらい経っていた。12時くらいになって「ん？ 何を書いているのか」と思って読み返しては、送る必要の全くない独り言だったので消した。

    自分は没頭しやすい。それはそれで強みだが、「2時間もメールを書いて結局送らない」というのは生産性がゼロである。とにかくそういう無駄を省いていきたい。

    --------------------------------------------------------------------------------

    そういう無駄を省くことが主目的なので、たとえばメールの送り先を事前登録しておいて誰に今週は何分かけたかを分析するなどは考えない。そこまですると管理コストが高まるし、グダグダが入るとデータとしての有用性が著しく低くなるため。「ちょっとメールを書いたついでに、途中で思い出したので必要なものをアマゾンで探し、他にも必要なものを思い出して買おうとしたが、情報が足りなかったのでググり、そのついでに他のことも調べた」などの全てがそのメールの所要時間となることに寛容なソフト。

    --------------------------------------------------------------------------------

    あとで「○○さんにメールを書いたときに△△もやった」と思い出すことがあるだろう。しかし、それをあとから追記できるようにすることが、今、目の前の時間の使い方の見直しに大きく貢献するとは思えない。日報を作って提出したいわけでないし、それで成果報酬額が決まるわけでもない。「だいたい何にどのくらいの時間を」というのをゆるくチェックし、グダグダを減らしたいだけ。

    --------------------------------------------------------------------------------

    mNextTasks
    mStartNextTasks
    mCurrentTasks
    mIsFocusless → mIsDisoriented
    mEndCurrentTasks
    mPreviousTasks
    mClose

    --------------------------------------------------------------------------------

    今のタスクに既にどのくらいの時間がかかっているかの表示をいったん見送る。必要ならすぐに追加できる。所要時間が見えた方が「時間をかけすぎている」と焦り、早く切り上げられる可能性があるが、逆に「まだこの程度か」と思う可能性もある。見えないからこそ急ぐこともあるか。

    --------------------------------------------------------------------------------

    先に Nekote に入れてライブラリー化してから使いたいコードが多いが、全てベタ書きしている。すぐに使いたいプログラムだし、Nekote に本当に必要なものは何か、まず Nekote なしでプログラムを書くことで考えたいため。

    --------------------------------------------------------------------------------

    所要時間の表示を見送ると書いたが、サクッと実装した。「今のタスク」のところにタスクが表示されるだけでは実行中の印象が弱かったため。

    --------------------------------------------------------------------------------

    基本的な機能が一通り揃い、使えるようになったので、ここからはタスクリストで完成度を高めていく。

[完了] 「メモ」タスクを完了にする
[完了] taskKiller のログを更新（繰り返す）
[完了] [7/22] いったんコミット（繰り返す）
[完了] Logs.txt のロード時に問題があった場合にメッセージを表示
[完了] 経過時間をタイトルバーに表示
[完了] 既存のコードを全体的にチェック
[完了] 全ての必要なメソッドで iUpdateControls が呼ばれているようにする
[完了] 落ちるところがないようにする
[完了] Closed でコントロールの内容を取得するのが安全か調べる
[完了] ログの追加時にリストを先頭にスクロールする
[完了] Logs.txt を timeLogs.txt に変更

    一意性があった方が他ディレクトリーに移動しやすい。

[却下] 多言語化
[完了] コントロールの状態の変化をテスト
[完了] ログの削除をボタンおよびキーで可能にする
[完了] マルチスレッドでコリジョンが発生しないのを確認
[完了] 時差やロケールが影響しないのを確認
[完了] Closing イベントを消す

    いつでも閉じることができてよい。開けば全て戻るように。

[完了] 全ての MessageBox の表示のコードをチェック
[完了] リストアされた情報に応じて Loaded でフォーカスを設定

    常に mNextTasks でよさそう。

[完了] シンプルな KVS 的なものを作る
[完了] プログラムの異常終了時にも状態が戻るようにする

    コントロールが操作された瞬間にセッション情報が保存されるようにした。

[完了] ソフトや Windows の再起動をしても現行のタスクなどが戻るようにする
[完了] KVS の文字のエスケープなどをテスト
[完了] 起動時に IME をオンにする
[完了] コメント
[完了] 実装
[完了] テスト
[完了] [7/27] taskKiller のログを更新（繰り返す）
[完了] [7/27] いったんコミット（繰り返す）
[完了] 仮のバイナリーを配置
[完了] アセンブリー情報を設定
[完了] コードを全体的にチェック
[完了] 投げる例外クラスを見直す

    Nekote の開発を少し進めたので、一応、整合させておく。

[完了] *Safe を *Safely に改名

    これも Nekote の開発により仕様が定まったため。

[却下] 作業の中断に対応できるようにする

    やめておく。

    「ちょっとトイレ」くらいなら数分だし、プログラムの操作を忘れて行くことも多い。「子どもが急に泣きだした」なら、プログラムの操作について考えることすらなく駆けつける。急な来客だったり、奥さんが声を掛けてきたりでも、「中断」ボタンを押すことはまず思いつかない。

    職場で集中していても日常的に発生する程度の頻度や長さの割り込みは「グダグダ」とみなすほどのことでないと考えるのが現実的。

    「グダグダ」をつけるのは、メールを書くだけのつもりだったのにアマゾンを開き、既に持っているものをチェックするために物置を見に行き、他のものを見つけ、そのメンテナンスのためにサビ取りを探し……などの、もっとガッツリと脱線した場合を想定。

[完了] iPreviousLogs を internal static にする

    internal だと XAML での WPF のコントロールとのバインディング時にコンパイラーがエラーを吐く「ことがある」という記憶があって public にしたが、今のところ再現していない。

[完了] MainWindow から静的プロパティーにアクセスする仕様について再考

    単一ウィンドウ・単一機能のプログラムなので、iPreviousLogs を作り、静的プロパティーなどを入れた。App.xaml.cs でデータのロードや保存の処理が必要になると思い、MainWindow 内の static でないプロパティーなどにデータを入れるのでは App.xaml.cs との受け渡しが面倒になりそうと思ったため。

    しかし、その後、

    ItemsSource="{Binding Source={x:Static local:iPreviousLogs.Logs}}"

    が突然コンパイル不可になった。

    MainWindow に static でないプロパティーを用意し、ElementName と Path でバインディングしたところコンパイルできた。

    MainWindow は、名前からも、基本的には一つだけ開かれるものだが、そうであっても単一プロセスで複数が同時に開かれても問題ないような設計を心掛けるべきなのだろう。

    入力画面を複数開けるプログラムなどでは当然そうしていたが、単一ウィンドウ・単一機能のプログラムでは手を抜く癖ができてしまっていた。

    timeLog を今後大きく変更する可能性が低いので、iPreviousLogs はそのまま。直すのがめんどくさいし、他にしなければならないことが多数あり、それらに取り組んだ方が生産的。設計を見直さないことにより派生開発のコストが増大するリスクはない。

[完了] DataContext について調べる

    WPF をちゃんとやったことがない。今さら、自分がバインディングについてほとんど理解していないと知った。

    --------------------------------------------------------------------------------

    Using the DataContext - The complete WPF tutorial
    https://www.wpf-tutorial.com/data-binding/using-the-datacontext/

    次のページによると、The purpose of other binding sources (RelativeSource, ElementName, etc) is to point to another property that doesn't exist in the current control's DataContext とのこと。

    wpf - What is DataContext for? - Stack Overflow
    https://stackoverflow.com/questions/7262137/what-is-datacontext-for

[完了] Binding における Source/RelativeSource と ElementName の違いを調べる

    RelativeSource は、親など、自分から見て相対的な関係にあるものとのバインディングに使われる。背景色を親と同じにするなど。

    RelativeSources in WPF
    https://www.c-sharpcorner.com/UploadFile/yougerthen/relativesources-in-wpf/

    RelativeSource MarkupExtension - WPF .NET Framework | Microsoft Docs
    https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/relativesource-markupextension

    --------------------------------------------------------------------------------

    DynamicResource と StaticResource についても読んだ。リソースデータの取得を実行時に試みるか、コンパイル時にそれが可能なことを確認するかの違い。

    DynamicResource Markup Extension - WPF .NET Framework | Microsoft Docs
    https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/dynamicresource-markup-extension

    StaticResource Markup Extension - WPF .NET Framework | Microsoft Docs
    https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/staticresource-markup-extension

    --------------------------------------------------------------------------------

    ElementName での検索は、VisualTree を必要とし、VisualTree における上下移動による要素の検索として行われる。

    wpf - What is the difference between x:Reference and ElementName? - Stack Overflow
    https://stackoverflow.com/questions/19244111/what-is-the-difference-between-xreference-and-elementname

    --------------------------------------------------------------------------------

    ContentElement を継承するものは VisualTree に含まれないとのこと。

    Understanding the Visual Tree and Logical Tree in WPF - CodeProject
    https://www.codeproject.com/Articles/21495/Understanding-the-Visual-Tree-and-Logical-Tree-in

    --------------------------------------------------------------------------------

    Source, RelativeSource, ElementName の違いについては、次のページがドンピシャ。

    How to: Specify the Binding Source - WPF .NET Framework | Microsoft Docs
    https://docs.microsoft.com/en-us/dotnet/desktop/wpf/data/how-to-specify-the-binding-source

    Source は、DataContext の設定によりスコープを設定することなく、特定のインスタンス化されたものにバインディングするためのもの。

    RelativeSource は、先ほど書いたメモの内容でいい。

    ElementName は、VisualTree における上下の移動で見つかる他の要素のプロパティーにバインディングするためのもの。

    RelativeSource では、

    Value="{Binding RelativeSource={x:Static RelativeSource.Self}, Path=(Validation.Errors)/ErrorContent}" とか、

    Text="{Binding RelativeSource={RelativeSource TemplatedParent}, Path=Value}" とかの書き方がある。

    RelativeSource Class (System.Windows.Data) | Microsoft Docs
    https://docs.microsoft.com/en-us/dotnet/api/system.windows.data.relativesource

    Binding RelativeSource= ... の部分を Binding Source= ... に変更するといかなる書き方でも動かないのかと考えると、今の自分には分からない。

    とりあえず、RelativeSource は、Binding RelativeSource= ... のあとにも RelativeSource を書くような状況で使うものと考えておく。Binding 直後の RelativeSource により「上へ下へ検索するモードでお願いしまっせ」を言い、実際どう検索するかを = 以降に書くものと。

    Source と ElementName の使い分けや可換性についてはまだ弱いので、もう少し調べる。

    --------------------------------------------------------------------------------

    MainWindow に

    private ObservableCollection <LogInfo> Hoge => iPreviousLogs.Logs;

    と書いたところ、

    ItemsSource="{Binding Source={x:Reference Name=mWindow}, Path=Hoge}"

    は起動すらせず、

    ItemsSource="{Binding ElementName=mWindow, Path=Hoge}"

    は起動には成功したものの、その後の処理でエラーが発生した。

    追記: 古いセッション情報が残っていてのエラーのようで、それを消してからの起動なら、後者の書き方はうまく動く。

    --------------------------------------------------------------------------------

    いろいろ調べたが、Source, RelativeSource, ElementName それぞれに「この状況だと、これしか使えない」というのがあるわけではなさそう。速度の比較も見られる。暫定的に、「したいことができれば、どれを使ってもよい」と考えることにする。

    第5回 WPFの「データ・バインディング」を理解する：連載：WPF入門（2/3 ページ） - ＠IT
    https://atmarkit.itmedia.co.jp/ait/articles/1010/08/news123_2.html

    wpf - ElementName vs. RelativeResource? - Stack Overflow
    https://stackoverflow.com/questions/4317097/elementname-vs-relativeresource

[完了] ListBox の ItemsSource がエラーを吐くようになったのを修正

    前回は次のコードでコンパイルできていた。それが急にできなくなった。

    ItemsSource="{Binding Source={x:Static local:iPreviousLogs.Logs}}"

    エラーメッセージ:

    型 'iPreviousLogs' が見つかりません。型名では大文字と小文字が区別されることに注意してください。

    --------------------------------------------------------------------------------

    DataContext について多少は理解した上、Logs 内の何かとバインディングするわけでないため意味がないと知りつつも

    DataContext="{x:Static local:iPreviousLogs.Logs}"

    と書いてみたところ、こちらでも型が見つからないというエラーが出た。

    --------------------------------------------------------------------------------

    MainWindow に

    private ObservableCollection <LogInfo> Hoge => iPreviousLogs.Logs;

    を追記し、いくつか試した。

    * ItemsSource="{Binding Source={x:Reference Name=mWindow}, Path=Hoge}" → 起動に失敗
    * ItemsSource="{Binding ElementName=mWindow, Path=Hoge}" → 起動に成功し、データが表示され、ログの追加に成功
    * ItemsSource="{Binding Path=Hoge}" → 起動に成功するが、データが表示されず、同じキーが2回追加されるエラー

    三つ目に

    <ListBox.DataContext>
        <Binding ElementName="mWindow" />
    </ListBox.DataContext>

    を追記すると、二つ目と同様に成功。

    それは、

    DataContext="{Binding ElementName=mWindow}" ItemsSource="{Binding Path=Hoge}"

    でも同じ。

    --------------------------------------------------------------------------------

    XAML でのバインディングをやめ、mWindow_Loaded に

    mPreviousTasks.ItemsSource = iPreviousLogs.Logs;

    を書くと、Hoge なしでも動く。

    となると、

    * Visual Studio では、静的プロパティーは、XAML のプレビュー時にはインスタンス化されて中身まで詰められるが、コンパイル時にはそこまでされない
    * そこまでされないため、ItemsSource にバインディングできるものとコンパイラーが正しく判断できず、（おそらくバグにより）型が見つからないというエラーになる
    * mWindow_Loaded での設定は、XAML の関与しない、型の一致のみ調べられることなのでコンパイルが通り、実行時には静的プロパティーに中身が詰まっているため動く

    という仮説が立つ。

    1週間ほど前にはコンパイルできていたコードが、ただ Visual Studio を閉じて、しばらくしてまた開いただけでコンパイル不可になったので、x:Static によるコードは、（インスタンス化される MainWindow から静的プロパティーにアクセスする点において仕様がダメという点はあっても）文法的には正しく書けていて、ただ Visual Studio がバグっているだけと考えてよさそう。

    実際、調べると、全く同じ状況で、全く同じコードで静的プロパティーとバインディングさせる例を多数見る。

    --------------------------------------------------------------------------------

    最終的にどうするか。

    iPreviousLogs.Logs というのは、単一ウィンドウ・単一機能のプログラムにおいて最初は App.xaml.cs でデータのロードや保存を行おうと思っていたからこそデータの受け渡しの簡略化のために用意したもの。

    やはり設計としてベストでないと思うので今後は気をつけるが、実装としての問題はないため、今回はそのまま使いたい。

    そのため、さらに ObservableCollection を用意することのない、mWindow_Loaded での ItemsSource の設定を結論とする。

[完了] [7/27] いったんコミット（繰り返す）
[完了] フォントを変更できるようにする

    .NET Core の、JSON による機能を使うか、簡単な KVS を用意するか、オワコンの ConfigurationManager をあえて使ってみるかのうち、あえてオワコンでいく。

    他は、今は準備不足だったり実装がめんどくさかったりだし、今後は ConfigurationManager を使わないため、現行のプロジェクトにも一つくらいそれを使うものがあってほしい。

    --------------------------------------------------------------------------------

    mWindow_Loaded での大きさの設定では、既にウィンドウの表示位置が決まっていて、モニターからはみ出す可能性がある。

    コンストラクターだと、InitializeComponent のあとなら大丈夫そうだが、それでも、まだコントロールの大きさやフォントをさわるのは早い気もする。

    そのため、mWindow_Initialized で処理を行った。

[完了] それぞれの入力欄が縦に自動的に伸びるようにする
[完了] 経過時間のフォントサイズが自動的に調整されるようにする

    FormattedText のコンストラクターの一部が古くなっている。

    c# - FormattedText.FormttedText is obsolete. Use the PixelsPerDip override - Stack Overflow
    https://stackoverflow.com/questions/45765980/formattedtext-formttedtext-is-obsolete-use-the-pixelsperdip-override

    --------------------------------------------------------------------------------

    FormattedText で得られる「高さ」には複数ある。

    Extent は、見える一番上のドットから一番下のドットまで。Padding が明確な枠内で上下にセンタリングしての表示ならフォントによりアセンダーなどが異なることは問題にならないはずなので Extent を使う。

    FormattedText Class (System.Windows.Media) | Microsoft Docs
    https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.formattedtext

    --------------------------------------------------------------------------------

    コントロールのコンテンツ部分の大きさの取得においては妥協する。

    TextBox は、内部に 2px の Padding を持つ。これを除去し、Text の左端を Border につけるには、Template を大きく変更することになる。

    TextBox Styles and Templates - WPF .NET Framework | Microsoft Docs
    https://docs.microsoft.com/en-us/dotnet/desktop/wpf/controls/textbox-styles-and-templates

    FrameworkElement.ActualWidth により実際の幅を得られるが、その全てが描画可能なエリアではない。

    FrameworkElement.ActualWidth Property (System.Windows) | Microsoft Docs
    https://docs.microsoft.com/en-us/dotnet/api/system.windows.frameworkelement.actualwidth

    おそらく、VisualTreeHelper を使って UI 要素をたどり、それぞれの Margin、Border の太さ、Padding などを合計すれば、描画可能でないエリアが得られる。そこから、描画可能なエリアの大きさも分かるだろう。

    しかし、経過時間の表示文字列を TextBox の枠線にぴったり内接させたいなどでないため、そこまでの作り込みは不要。

    --------------------------------------------------------------------------------

    フォントサイズを決めるにおいては「999時間59分」の大きさを調べる。

    タスクに100時間以上かかることがない。寝ている間も計測を続けるようなタスクは考えにくい。

    となると、あり得るのは、タスクを開始し、そのまま忘れてしまい、パソコンがスリープし、久々に開いたときに4日とちょっと以上が経過していた場合。この場合、「時間」が3桁になる。

    しかし、40日以上もスリープが続いて999時間を超えることはまずない。

    あったとしても、表示が乱れるだけであり、実害が発生しない。

    --------------------------------------------------------------------------------

    「高さ」に Extent を使うのをやめて、Height を使うようにした。

    VerticalContentAlignment が Center でも、フォントのアセンダーなどの部分の余白が上下に均等にはみ出てくれるわけでないようだから。

    つまり、「アセンダー + Extent ＋ ディセンダー」が ActualHeight より大きくなると、下にだけはみ出て、Extent 部分が、上下方向にセンタリングされた位置より下にズレる。

    --------------------------------------------------------------------------------

    Height を使う場合、それが ActualHeight と近似する値であるにおいて、実際には枠線の太さだったり内部的な（見えない）Padding があればそれに影響されたりも考えないといけないわけで、フォントがギリギリまで大きくなったときに上下方向のセンタリングがわずかにズレる可能性を考える必要がある。

    しかし、目視でテストした限りは大丈夫のようなので、しばらく様子見。

[完了] [8/2] いったんコミット（繰り返す）
[完了] [7/27] taskKiller のログを更新（繰り返す）
[完了] 仮のバイナリーと設定を更新
[完了] 価値の有無を区別できるようにする

    統計処理のため、価値のあることとあまりそうでないことを区別する。

    トヨタだったと思うが、「掃除や片付けは（生産活動でないので）仕事でない」か何か、そういう考え方が社内に行き渡っていると聞いたことがある。

    たとえば子供同士が仲いいから親ともやり取りしてのママ友へのメール返信は、それがなくてもアポだけ取り急ぎ取れば子供同士は遊べる点において不可欠でない。普段あまりにもコミュニケーションが少ないと子供同士の遊びにも影響が生じうるが、関係がそれなりに良好なら、なくてよいメールはたくさんある。

    逆に、ちょっと筋トレするようなことは、たった5分でも毎日やれば効果があるようで、それで筋肉が増えて代謝が上がって脂肪が減れば動脈硬化を遅らせることにもなるはずで、おそらく有意に余命が伸びる。

    最初は仕事かどうかという区別を考えたが、それだと筋トレは仕事でないから timeLog では重要でないとされる。

    また、仕事にもいろいろあって、どうでもよいことも多い。そういうのは、仕事であっても「有効活用されなかった時間」として集計されるべき。

    一応の配慮として、「価値なし」という表現はプログラムに含めない。

    たとえば自分を友達と思ってくれている人へのメール返信は、それが社会的な価値を創出することはないかもしれなくとも、全く無意味なことではない。

    という考え方により、「価値あり」のみ表現するように UI などを工夫する。

[完了] コードを全体的に軽くチェック
[完了] 統計処理を実装

    「価値なし」を UI などに入れたくなかったが、入れた方が分かりやすくなりそうなので入れる。

    また、「グダグダ」の反対として「集中」を入れる。

    ListBox に「集中」が表示されないよう、Visibility が変更されるようにする。

    --------------------------------------------------------------------------------

    時間の使い方を階層的に表示し、それぞれに％表示もつけた。

    --------------------------------------------------------------------------------

    昔は完徹もちょくちょくあったが、今は翌日に響くので遅くても3時過ぎには寝る。早起きは、早くても5時くらいで、4時以前に起きることはまずない。

    そのため、12時でなく4時に「日」が変わるとみなす実装にした。

    もちろん例外も出てくるが、そもそも timeLog のデータは信頼性が低い。タスクを timeLog でスタートするのを忘れて何時間か取り組んでから「集中しているのに記録を残せない」と惜しむこともあれば、タスクがとっくに終わっているのに timeLog では切るのを忘れて半日取り組んだようになることもある。

    リストにはできるだけ正確な情報を入れ、操作をミスったならエントリーごと消し、とりあえず既存のデータを4時でぶった切って目安程度の統計情報を表示するというのが限界。

[完了] 起動時に最大化できるようにする
[完了] [8/2] taskKiller のログを更新（繰り返す）
[完了] [8/2] いったんコミット（繰り返す）
[完了] [8/2] 仮のバイナリーと設定を更新
[完了] README.md を書く
[完了] [8/7] taskKiller のログを更新（繰り返す）
[完了] アーカイブ
[完了] [8/7] いったんコミット（繰り返す）
[完了] 配置しているバイナリーを更新
[却下] 失敗や打ち切りのフラグを用意するか考える

    なかったことにした方が気分が沈まないか。

    たとえば晩飯のあと、なんとなくダラダラしたなら timeLog の記録に残らないのに、メールを書こうとしてやっぱり気乗りせずやめたなどだと「失敗」または「打ち切り」の記録が残る。そういう、自分の気分を高めない情報を積極的に扱うことはない。
